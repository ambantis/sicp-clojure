(ns sicp-clojure.1-2
  (:gen-class))

;;;; 1.2 Procedures and the Processes They Generate

;; A procedure is a pattern for the "local evolution" of a computational
;; process. It specifies how each stage of the process is build upon the
;; previous stage. In this section, we look at some common "shapes" for the
;; processes generated by simple procedures.

;;; 1.2.1 Linear Recursion and Iteration

;; We begin by considering the factorial function using a linear recursive process:


(defn fact1
  "Return Factorial using recursive process"
  [n]
  (if (= n 1)
    1
    (* n (fact1 (- n 1)))))

;; (factorial 6)        ------------------------.
;; (* 6 (factorial 5))                          |
;; (* 6 (* 5 (factorial 4)))                    |
;; (* 6 (* 5 (* 4 (factorial 3))))              |
;; (* 6 (* 5 (* 4 (* 3 (factorial 2)))))        |
;; (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
;; (* 6 (* 5 (* 4 (* 3 (* 2 1)))))              |
;; (* 6 (* 5 (* 4 (* 3 2))))                    |
;; (* 6 (* 5 (* 4 6)))                          |
;; (* 6 (* 5 24))                               |
;; (* 6 120)                                    |
;; 720          <-------------------------------'

;; Another approach could be building up a value, keeping a running sum.

(defn fact2
  "Return Factorial using iterative process"
  [n]
  (loop [acc 1
         i 1]
    (if (> i n)
      acc
      (recur (* i acc)
             (inc i)))))

;; (factorial 6)   -----.
;; (fact-iter   1 1 6)  |
;; (fact-iter   1 2 6)  |
;; (fact-iter   2 3 6)  |
;; (fact-iter   6 4 6)  |
;; (fact-iter  24 5 6)  |
;; (fact-iter 120 6 6)  |
;; (fact-iter 720 7 6)  V
;; 720


;; The two functions evaluate to the same result, but using very different
;; shapes. The recursive process builds up a chain of deferred computations. In
;; order to know the state, you need to understand the state of the stack. In
;; contrast, with an iterative shape, the accumulated state of the computation
;; is state (or a parameter) of the function.


;; Exercise 1.9: Each of the following two procedures defines a method for
;; adding two positive integres in terms of the procedures `inc', which
;; increments its argument by 1, and `dec', which decrements its argument by 1.
(defn my-plus1
  ""
  [a b]
  (if (= a 0)
    b
    (inc (my-plus1 (dec a) b))))

(defn my-plus2
  ""
  [a b]
  (if (= a 0)
    b
    (my-plus2 (dec a) (inc b))))

;; These processes are recursive

;; Exercise 1.10: The following procedure computes a matehmatical function
;; called Ackermann's function.

(defn ackerman
  "Ackerman's function"
  [x y]
  (cond
    (= y 0) 0
    (= x 0) (* 2 y)
    (= y 1) 2
    :else (ackerman (- x 1) (ackerman x (- y 1)))))

;; What are the values of the following expressions?
;;
;; (ackerman 1 10) => 1024
;; (ackerman 2 4) => 65536
;; (ackerman 3 3) => 65536
;;
;; Consider the following procedures, where `A' is the procedure defined above:
;;
;; (defn f [n] (ackerman 0 n)) => computes 0
;; (defn g [n] (ackernam 1 n)) => computes 2^n
;; (defn h [n] (ackernam 2 n)) => computes (2^n)^2

;;; 1.2.2 Tree Recursion

;; Another common pattern of computation is "tree recursion", and Fibonacci
;; numbers are an example of this, in the sequence:

;; 0, 1, 1, 2, 3, 4, 8, 13, 21, ...

;;          | 0 if n = 0
;; fib(n) = | 1 if n = 1
;;          | fib(n-1) + fib(n-2)

;; Consider a recursive procedure implemmentation:

(defn fib1
  "Expensive computation of Fibonacci"
  [n]
  (cond
    (= n 0) 0
    (= n 1) 1
    :else (+ (fib1 (- n 1)) (fib1 (- n 2)))))

;; While this function is illustrative of tree recursion, it is a terrible way
;; to compute the Fibonacci sequence becuase there is so much redundant
;; computation. Consider:

;;                    ..<............ fib5   <..........
;;                 ...     ___________/  \___________   .
;;              ...       /       . .....            \    .
;;            ..       fib4     .        . . . .     fib3  .
;;          ..     ____/. \____  ..             .  __/  \__  .
;;        ..      /  . .  ..   \    .        ..   /  . .   \   .
;;      ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
;;    ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
;;  ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
;; .      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
;; .      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
;; V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
;; .  fib1 .. fib0..  .   .   .   .   .   V   .   ..  .
;; .   |  .  . |  . .>     .>.     . .    ..>.      .>
;; .   1 .   . 0  .
;;  .   .     .  .
;;   .>.       ..

;; This computation grows exponentially in terms, but minimizes memory usage.
