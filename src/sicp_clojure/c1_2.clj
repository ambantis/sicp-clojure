(ns sicp-clojure.c1-2
  (:require [sicp-clojure.c1-1 :as c1-1]))

;;;; 1.2 Procedures and the Processes They Generate

;; A procedure is a pattern for the "local evolution" of a computational
;; process. It specifies how each stage of the process is build upon the
;; previous stage. In this section, we look at some common "shapes" for the
;; processes generated by simple procedures.

;;; 1.2.1 Linear Recursion and Iteration

;; We begin by considering the factorial function using a linear recursive process:

(defn fact1
  "Return Factorial using recursive process"
  [n]
  (if (= n 1)
    1
    (* n (fact1 (- n 1)))))

;; (factorial 6)        ------------------------.
;; (* 6 (factorial 5))                          |
;; (* 6 (* 5 (factorial 4)))                    |
;; (* 6 (* 5 (* 4 (factorial 3))))              |
;; (* 6 (* 5 (* 4 (* 3 (factorial 2)))))        |
;; (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
;; (* 6 (* 5 (* 4 (* 3 (* 2 1)))))              |
;; (* 6 (* 5 (* 4 (* 3 2))))                    |
;; (* 6 (* 5 (* 4 6)))                          |
;; (* 6 (* 5 24))                               |
;; (* 6 120)                                    |
;; 720          <-------------------------------'

;; Another approach could be building up a value, keeping a running sum.

(defn fact2
  "Return Factorial using iterative process"
  [n]
  (loop [acc 1
         i 1]
    (if (> i n)
      acc
      (recur (* i acc)
             (inc i)))))

;; (factorial 6)   -----.
;; (fact-iter   1 1 6)  |
;; (fact-iter   1 2 6)  |
;; (fact-iter   2 3 6)  |
;; (fact-iter   6 4 6)  |
;; (fact-iter  24 5 6)  |
;; (fact-iter 120 6 6)  |
;; (fact-iter 720 7 6)  V
;; 720

;; The two functions evaluate to the same result, but using very different
;; shapes. The recursive process builds up a chain of deferred computations. In
;; order to know the state, you need to understand the state of the stack. In
;; contrast, with an iterative shape, the accumulated state of the computation
;; is state (or a parameter) of the function.

;; Exercise 1.9: Each of the following two procedures defines a method for
;; adding two positive integres in terms of the procedures `inc', which
;; increments its argument by 1, and `dec', which decrements its argument by 1.
(defn my-plus1
  ""
  [a b]
  (if (= a 0)
    b
    (inc (my-plus1 (dec a) b))))

(defn my-plus2
  ""
  [a b]
  (if (= a 0)
    b
    (my-plus2 (dec a) (inc b))))

;; These processes are recursive

;; Exercise 1.10: The following procedure computes a matehmatical function
;; called Ackermann's function.

(defn ackerman
  "Ackerman's function"
  [x y]
  (cond
    (= y 0) 0
    (= x 0) (* 2 y)
    (= y 1) 2
    :else (ackerman (- x 1) (ackerman x (- y 1)))))

;; What are the values of the following expressions?
;;
;; (ackerman 1 10) => 1024
;; (ackerman 2 4) => 65536
;; (ackerman 3 3) => 65536
;;
;; Consider the following procedures, where `A' is the procedure defined above:
;;
;; (defn f [n] (ackerman 0 n)) => computes 0
;; (defn g [n] (ackernam 1 n)) => computes 2^n
;; (defn h [n] (ackernam 2 n)) => computes (2^n)^2

;;; 1.2.2 Tree Recursion

;; Another common pattern of computation is "tree recursion", and Fibonacci
;; numbers are an example of this, in the sequence:

;; 0, 1, 1, 2, 3, 4, 8, 13, 21, ...

;;          | 0 if n = 0
;; fib(n) = | 1 if n = 1
;;          | fib(n-1) + fib(n-2)

;; Consider a recursive procedure implemmentation:

(defn fib1
  "Expensive computation of Fibonacci"
  [n]
  (cond
    (= n 0) 0
    (= n 1) 1
    :else (+ (fib1 (- n 1)) (fib1 (- n 2)))))

;; While this function is illustrative of tree recursion, it is a terrible way
;; to compute the Fibonacci sequence because there is so much redundant
;; computation. Consider:

;;                    ..<............ fib5   <..........
;;                 ...     ___________/  \___________   .
;;              ...       /       . .....            \    .
;;            ..       fib4     .        . . . .     fib3  .
;;          ..     ____/. \____  ..             .  __/  \__  .
;;        ..      /  . .  ..   \    .        ..   /  . .   \   .
;;      ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
;;    ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
;;  ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
;; .      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
;; .      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
;; .     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
;; .  fib1 .. fib0..  .   .   .   .   .   V   .   ..  .
;; .   |  .  . |  . .>     .>.     . .    ..>.      .>
;; .   1 .   . 0  .
;;  .   .     .  .
;;   .>.       ..

;; This computation grows exponentially in terms, but minimizes memory usage. In
;; contrast, the iterative solution produces a result that is proportional to
;; the size of N, rather than exponential:

(defn fib2
  [n]
  (if (< n 1)
    0
    (loop [a 1
           b 1
           i 1]
      (if (= i n)
        a
        (recur b (+ a b) (inc i))))))

(def fib-memoized (memoize fib2))

;; This does not mean that tree recursion is never useful, it is a natural and
;; powerful tool.

;; In some cases, however, there is no alternative to tree recursion. Consider,
;; for example, counting change. How many different ways can we make change for
;; $1.00, given half-dollars, quarters, dimes, nickels, and pennies.

;; We can reason about the solution to the problem as two cases:
;;   a. number of ways to change `a' using all but the first kind of coin, plus
;;   b. number of ways to change amount `a - d' using all `n' kinds of coins,
;;      where d is the denomination of the first kind of coin

;; This is because the solution can be divided between those that use the first
;; kind of coin and those that do not. Thus, we can recursively reduce the
;; problem of changing a given amount to the problem of changing smaller amounts
;; using fewer kinds of coins.

;; Here is the algorithm:
;;   * if `a' is exactly 0, we should count that as 1 way to make change.
;;   * If `a' is less than 0, we should count that as 0 ways to make change.
;;   * If `n' is 0, we should count that as 0 ways to make change.

(defn first-denomination
  [kinds-of-coins]
  (cond (= kinds-of-coins 1) 1
        (= kinds-of-coins 2) 5
        (= kinds-of-coins 3) 10
        (= kinds-of-coins 4) 25
        (= kinds-of-coins 5) 50))

(defn cc
  [amount kinds-of-coins]
  (cond (= amount 0) 1
        (or (< amount 0) (= kinds-of-coins 0)) 0
        :else (+ (cc amount
                     (dec kinds-of-coins))
                 (cc (- amount (first-denomination kinds-of-coins))
                     kinds-of-coins))))

(defn count-change [amount]
  (cc amount 5))

;; The observation that a tree-recursive proces maybe highly inefficient but
;; often easy to specify and understand has let people to propose that one could
;; get the best of both worlds by designing a "smart compiler" that could
;; transform tree-recursive procedures into more efficient procedures that
;; compute the same result.

;; Exercise 1.11: A function `f' is defined by the rule that f(n) = n if n < 3
;; and f(n) = f(n-1) + 2f(n-2) + 3f(n-3) if n >= 3. Write a procedure that
;; computes `f' by means of a recursive process. Write a procedures that
;; computes `f' by means of an iterative process.

(defn f-recursive
  [n]
  (if (< n 3)
    n
    (+ (* 1 (f-recursive (- n 1)))
       (* 2 (f-recursive (- n 2)))
       (* 3 (f-recursive (- n 3))))))

(defn f-iterative
  [n]
  (if (< n 3)
    n
    (loop [acc '(2 1 0)
           i 2]
      (if (= i n)
        (first acc)
        (let [f1 (nth acc 0)
              f2 (nth acc 1)
              f3 (nth acc 2)
              next (+ (* 1 f1)
                      (* 2 f2)
                      (* 3 f3))]
          (recur (conj acc next)
                 (inc i)))))))

;; Exercise 1.12: The following pattern of numbers is called "Pascal's
;; triangle".

;;              1
;;            1   1
;;          1   2   1
;;        1   3   3   1
;;      1   4   6   4   1

;; The numbers at the edge of the triangle are all 1, and each number inside the
;; triangle is the sum of the two numbers above it. Write a procedure that
;; computes elements of Pascal's triangle by means of a recursive process

(defn- private-pascal-next
  "Return next row of Pascal's Triangle, given seq of current row"
  [row]
  (loop [acc (list 1)
         rem row]
    (let [[a b] rem]
      (if (nil? b)
        (conj acc 1)
        (recur (conj acc (+ a b)) (rest rem))))))

(defn pascal
  "Return Pascal's Triangle with `n' rows, as a list of lists'"
  [n]
  (cond (< n 1) ()
        (= n 1) (list (list 1))
        :else (let [[base :as triangle] (pascal (dec n))]
                (conj triangle (private-pascal-next base)))))

(defn print-pascal
  "Print Pascal's Triangle with `n' rows'"
  [n]
  (doseq [row (reverse (pascal n))] (println (clojure.string/join " " row))))

